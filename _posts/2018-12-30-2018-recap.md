---
layout: post
title: "2018 Recap"
date: 2018-12-30
permalink: /2018-recap/
categories: meta
excerpt_separator: <!--more-->
---

Here's a summary of the things I made this year - mostly libraries and
experiments relating to games and computer graphics. Many of these projects
deserve a dedicated post explaining them in further depth, and I intend to
elaborate further in future posts. All these projets are written in rust.
Headings link to the projects on github. All animations are realtime screen
recordings.

## [Wave Function Collapse Library](https://github.com/stevebob/wfc)

![wfc cat](/images/2018-recap/wfc-cat.png)

Wave Function Collapse is a procedural generation algorithm which takes as input
a list of tiles, rules describing which tiles may appear adjacent to one another
in the output, and the relative frequency with which each tile should appear in
the output. A common way of specifying this input is in the form of an example
image which looks similar to the desired output.

<!--more-->

The image above was generated from this example:

![cat](/images/2018-recap/cat.png)

I first read about WFC here: [mxgmn/WaveFunctionCollapse](https://github.com/mxgmn/WaveFunctionCollapse).
That page contains links to many other implementations and explanations of the algorithm.

Here's another example showing the order in which pixels are filled in using my
library:

![flowers animation](https://raw.githubusercontent.com/stevebob/wfc/master/images/flowers-animate.gif)

The example image is below. Pixel colours are the probability-weighted-average of all the possible
colours that could end up in that position.

![flowers](https://raw.githubusercontent.com/stevebob/wfc/master/images/flowers.png)

I'm still adding minor ergonomic improvements to the api to this library, but
it's currently in a working state, and I intend to use it to generate levels for
a roguelike soon.

## [Per-Pixel Visible Area Detection](https://github.com/stevebob/pixel-shadow-experiment/)

![shadows1](/images/2018-recap/shadows1.gif)
![shadows2](/images/2018-recap/shadows2.gif)

## [Platform Game Physics](https://github.com/stevebob/simple-physics)

![collisions](/images/2018-recap/collisions.gif)
![collisions bad](/images/2018-recap/collisions-bad.gif)


<a name="simon"></a>

## [Simon - an Arg Functor](https://github.com/stevebob/simon)

This is a library for parsing command line arguments. All the command line
parsing arguments I could find were similar to [python argparse](https://docs.python.org/3/library/argparse.html),
in that one must register the arguments with a parser, then have the parser
parse the arguments into some structure, then extract the argument values from
that structure. There are two problems with this. Firstly, one must repeat
oneself - the argument names must be specified when registering, **and**
extracting the arguments. Secondly, since rust is statically-typed, parsing all arguments into a common structure
forces arguments to be homogeneous.

Simon is a library of combinators, allowing one to compose basic parsers and
operations on parsed values, to form parsers of complex data. It's best
explained by example:

```rust
extern crate simon;

#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let parser = simon::opt_required("n", "name", "your name", "NAME")
        .both(simon::opt("a", "age", "your age", "NUM").with_default(42))
        .map(|(name, age)| Person { name, age })
        .with_help_default();

    let person = parser.parse_env_default_or_exit();

    println!("{:?}", person);
}
```

Running it:
```
$ ./foo -a 26 -n Steve
Person { name: "Steve", age: 26 }

$ ./foo
name is required but not supplied

Usage: ./foo [options]

Options:
    -h, --help          print this help menu
    -n, --name NAME     your name
    -a, --age NUM       your age
```

It's named for the fact that it is an ![http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors](applicative functor).
Thus far, every time I've explained the name, I've also had to explain the fact
that it's a joke. If you get the joke, you may be the first!

## [Conway's Game of Life in an OpenGL Shader](https://github.com/stevebob/life-gl)

For a bit of fun I decided to try implementing [Conway's Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life),
in such a way that the logic for determining if a cell lives or dies is
implemented in a fragment shader.

![life-gl](https://raw.githubusercontent.com/stevebob/life-gl/master/images/screenshot1.png)

I've implemented Conway's Game of Life many times. [It's even implemented on
this blog.](/cellular-automata-cave-generation/) This implementation is
interesting because each frame, the per-cell computation is done on the GPU,
allowing for a great deal of parallelism. When a frame is rendered, it is also
rendered to a texture. When the following frame is rendered, it samples that
texture so it can check which cells are alive, and which are dead.

It was adding the command line options to this program that motivated me to make
[simon](#simon).

## [Generating wall geometry from a grid map](https://github.com/stevebob/walls-experiment)

I've been using opengl for several years now, but never rendered anything 3d. I
made a tiny program which takes a text description of a wall map, like:

```
.......
.###.#.
.#.###.
.#.#.#.
.......

```

And renders a scene like:
![walls](/images/2018-recap/walls.png)

It's not particularly impressive, but at least now I have something to build
upon when I want to experiment with something more complicated.

## [Quadtree Library](https://github.com/stevebob/quadtree)

This is an unfinished implementation of quadtrees in rust. I had ambitions of
making a realtime 2d platform game (or at least the engine thereof), which I
still haven't done. I want to have a solid story for collision detection, and
fast collision detection relies on being able to enumerate all the things which
are near a particular thing (as it's infeasible to perform a collision test on
every pair of objects in the world). Quadtrees are a family of data structures
which divide a space into a hierarchy of smaller spaces. I intended to compare
several different incarnations of this idea, but got distracted after
implementing one. I even started a blog post explaining how quadtrees work, and
why they're useful, which I never finished. Maybe next year!

Enjoy this graphic which I made for the blog post!

![quadtree](/images/spatial-queries-with-quadtrees/cover.png)

I also made a [persistent quadtree library in ocaml](https://github.com/stevebob/loose-quadtree-ocaml), to use for the aforementioned
blog post, with the idea being that I think ocaml beats rust as a language for humans
to communicate with other humans about computing ideas.
